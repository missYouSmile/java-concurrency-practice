package com.artc.concurrency.chapter2;

/**
 * volatile : 并不能保证并发操作的正确性, 只能保证 '可见性'.
 * 可见性 : java线程模型保证, 所有线程看到的变量的值是一致的.
 * 其实, 可见性:
 *  A. 由CPU指令( lock )保证
 *      lock 操作 : ( 缓存更新的套路, 分布式缓存类似 )
 *          1. 将当前缓存行的数据写回到系统内存
 *          2. 使其他CPU中的缓存失效
 * */
public class VolatileDemo {

    /**
     * CPU 术语:
     * 内存屏障 ( memory barriers ): 是一组处理器指令, 用于实现对内存操作的顺序限制
     * 缓冲行 ( cache line ) : cpu 高速缓存中最小的存储单元 ( 伪共享 )
     * 原子操作 ( atomic operations ) : 不可中断的一个或一组操作
     * 缓冲行填充 ( cache line fill ) : 当处理器认为读操作是可缓存的, 则读取整个缓存行到高速缓存中.
     * (PS: 跟我想的不太一样, 这个解释不就是: 读取缓存? 我的理解是, 当一个变量的大小不足一个缓存行的大小时, 进行类似 字节填充的操作
     * 填满缓冲行, 保证一行的缓存只对某个缓存操作有效, 而不会影响别的缓存, 用以解决 '伪共享')
     * ...
     */


}
